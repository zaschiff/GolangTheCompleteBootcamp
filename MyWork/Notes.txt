GOPATH -
    Is the environment variable pointing to a folder under the user directory 
    that contains the source code for the go installation. They are in the src 
    directory and it is common practice to store source code in the package 
    to which it is named.

Code syntax -
    package 'package name' ==> this is the package clause and is the first line
    of code. It declares the name of the package that the go file belongs to.
    if it is not named Main, go will nto execute the code.

    func ==> the keyword to declare a named function that we create.
    The funciton named main is the entry point to the program.

Use the go tools in the command line to run or build your code.
    To build and executable, use go buil 'file name'
    To build, run, and delete the executable in one command use go run 'file name'

Packages -
    There are rules
        R1. All package files that should be in the same directory
        R2. All files in the same directory should belong to the same package
    Each Go package has it's own scope
    There are only two kinds of Go packages: Executable and Library
        Executbale ==> declared with package mian and has a main funcction. Only created for running as program. Not importable
        Library ==> package name matches folder directory and does not containt a main function.It is created only for reusability. 
            importable but not executable
    
Scopes -
    scope is the visibility of an object. Who can see the object.
    Declaration ==> delcares a unique name bound to a scope. Same name cannnot be declared twice with in the same scope.
    
    objects outside a function (like inbetween the import statement and the first function) are package scope, the entire pacakge can see the object.
    If an object is clared between {}, this is considered blocked scope. The object is only visible between matching {}.

    File scope is all objects are visible to the file. Each Go file has it's own scope.

Importing -
    allows a file to use the functionalities from a library package. Importing only happens as the file level.

    Imports can be renmaed to allow duplicate pakcge importing. 
        apply the alias between the import statement and the name of the package 
        ie: import f "fmt", this sets an alias 'f' for the 'fmt' import.

Statments -
    statements instruct go to do something. 
    They are generally one line of code unless separated by a semicolon (;).
    They control the execution flow.

Expressions - 
    line of code that computes one or more values.
    expressions should be used with or within a statement.
    some statements like func calls can also act like expressions.

Comments -
    use comments to explain or document code.
    a single line comment is stated with //
    a multi line comment starts with a /* and ends with */
    There is a command in go to create documentaiton about the project using the comments in the file automatically. 
        The tool is called go doc

Exporting - 
    allows a package to make its functionalities available to other packages.
    To export something, after declaring the name of anobject make the first letter of the name capitlaized
        ie: var cheese string, the variable cheese is not exported. var Cheese string is an exported variable.

Variables -
    is a storage box for a value. They can be named or unanmed and when called give you access to the value inside. 
    a static type is a type of variable that can not have its typed changed once declared. However, you can change the value 
    to another value as long as it is the same type.

    Basic data types - 
        most basic types in go
        int         => a whole number, signed or unsigned ie: -1 0 27
        float64     => a non-whole number ie: .5 0. 1.2
        bool        => only represent true or false
        strng       => a word or multiple charachters ie: "hi" "hello there"

    Declaring a Variable, Syntax -
        must be delcared before you can use. 
         syntax is as follows: var speed int
            var     ==> keyword to declare a variable
            speed   ==> name fo the variable or also known as the identifier
            int     ==> type of the variable
    
        In go every variables have a type

        Naming rules:
            names should always start with a letter or underscore character.
            names can not start with numbers or punctuation marks
            names can not contian punctuation marks
            names can not use keywords from go.

        if not initialized to a value, go will initialize a variable to it's zero value
        Zero values get applied to an emtpy variable according to it's type
            int         ==> 0
            float       ==> 0
            bool        ==> false
            string      ==> ""
            pointers    ==> nil

    Blank Identifier -
        go does not allow declaraion of unused variables. Unused variables cause maintenance nightmares. 
        You are not required to use package level variables.

        allows us to use and discard the value of a variable. 
    
    Multiple variables can be declared using the comma (,) as a separator as long as they are the same type or 
        you can wrap them in parentheses () after the var keyword if the types are different

    Initialization can be done at the saem time as declaration using the assingment operator (=)

    Go uses type inference. This means that the compiler can figure out the type of variable using the vlaue that it contains.

    Short declaration is a variable declaration syntax that declares and initializes the value in one statement. The short declaraion operator is :=
        Short declaration works at block scope, it can't be used for package scope variables.
    The short declaration can be used with mutliple variable assignment. they do not need to be the same type to usse :=
    It acan also be used on a previsoulse declared variable as ong as it is in multiple assignment and at least one new variable is new.

    When deciding to use a short variable vs normal - 
        Use Normal Declaration when:
            When you don't know the initial value
            When you need a package scope variable
            When you want to group variables together for readability

        Use Short declaration when: (mostly used and preferred)
            When you know the initial value.
            to keep code concise
            for redeclaration

    Assignment -
        use the assignment operator (=) to change the value of a variable. This doesn't declare a new variable.
        When assigning a value to a varibale it MUST match the type of the variable.
        the assignment operator supports multiple variable assignment.
        Using the multiple assingment sytanx we can swap two variables.
        
Type Conversion -
    since we have mutliple types, we may nee to take one type and make it into another. Go offers type conversion.
        the syntax for type conversion is similar to many other languages. 
            type(value)
        
        type  ==> the type we want to convert to
        value ==> value we are trying to convert.

Type Names -
    the type indicates the type and the size of the type. An Int32 is 4 bytes long and it is not the same as int.

Slices -
    Slices is a go type that can store multiple values
    syntax is [] and the type it will store. Once declared it can only store that type. IE []string, is a slice of strings only
    Go is a zero index language. We acces the items in a slice using index number inside [] ie [0] is the first item in a slice

Printf - 
    prints formatted output.
    the syntax for printf is similar to many other print functionalities but with addtional functionality
        Printf("%q\n", variable)
            Printf  ==> the function call
            %q      ==> the formatting text, determines the what and how to print.
            variabe ==> replacer values, these are the values that replace the formatted text.
    verbs can be used as many times as wanted and with other verbs.

Escape Sequences -
    special modifier that gives special meaning in the print functions. They are always denoted by a a backslash (\)
    due to this we need to escape any symbols that are used in a string that activate special meanings like if we need a backslash in a string we type \\
    
    Escape sequences:
        \a          - alert or bell
        \b          - backspace
        \f          - form feed
        \n          - new line
        \r          - carriage return
        \t          - horizontal tab
        \v          - vertical tab
        \\          - backslash
        \"          - double quotes
        \ooo        - octal digit
        \xhh        - byte, h is hex
        \uhhhh      - unicode, h is hex digits
        /Uhhhhhhhh  - unicode, h is 8 hex hex digits

Formatter input -
    %T - Type of the value passed
    %v - value in default format
    
    others can be found at https://golang.org/pkg/fmt/
    we can pass an arguments index to the formatting verb to select which argument we want using []

Arithmetic Operators -
    Normal math operations can be done using the normal operators in go
        * - multiplication
        + - addtiona
        - - subtraction/negation
        / - division
        % - remainder or modulus, only works on integers
    Computers struggle with floating part numbers and can create inaccuracies based on precision. BE CAREFUL!!!

    Computers do have precendence or order of operations.
        we can change that order using parentheses ()
        order of operations is as follows:
            top from left to right
                * / % << >> & &^
                + - | ^
                == != < <= > >=
                &&
                ||

    GO does offer an increment and decrement method to either increase or decrease by one
        the syntax is as follows:
            value++ ==> increase value by 1
            value-- ==> decrease value by 1
        this is called the incdec statement and cannnot be used as an expression. GO considers this a statement
        and must be on its own line of code.
            5 + n-- does not work!!!

String Literals -
    a string litteral is a single line string wraped in double quotes
    a raw string literal is wrapped in back quotes (``) and it can span multiple lines. 
        it is not interpreted. IE if the raw string literal has a new line escape sequence, 
        go will not see it as such.

    Strings can be concatenated or combines together using the + operator to create a new string.
    we can also use the len command to get the length of a string. However, this command returns 
        the number of bytes but not the number of characters. We would use a different function
        to count another type called a rune or single character. The rune coutn function is 
        under the unicode/utf8 package.

Bits and Bytes -
    bit is a 0 or 1. It is the smallest form of data a computer can have. It represents data
    More bits means more values that can be represented.

    Bytes, is the next step of data and it groups bits. 1 Byte = 8 Bits.
    Just like with bits, more bytes means more information we can represent.
    a byte type go is like an unsigned integer of 8 bits

    Predeclared types are built in types to the language.
        The predeclared types are as follows:
            bool ==> True or False                  string  ==> "hello world"
            
            int  ==> int32 or int64,
                capactiy dependent. The numebr is the bit size. 
                more bits means more memory needed
                    These are signed there is the unsigned only variation of uint
                int8
                int16
                int32 (also a Rune, 
                    same type but diffrent or aliased type)
                int64

            Float32 ==> samething as flaot64 only 32 bytes.
            Float64 ==> fractional part 
                numbers

            complex64  ==> two float32 byte values 
            complex128 ==> two float64 byte values

    if we give a value that goes higher than the types limit then, the valeu will wrap around.
    ie if we try to give a utin8 a value of 256, the value will become 0

Defined Type -
    a defined a user created type that has an underlying type.
    a defined type is also called a named type.
    The syntaxt for creating a new type is as follows:
        type duration int64
        type     ==> keyword to declar a new type
        duration ==> name of the deinfed type
        int64    ==> the underlying type that duration is based on
    a deined type gets it's properties from the underlying, predeclared type. However, the named 
        type and underlying type are still considered different by the compiler.
    you can also convert a named type to another named or predeclared type as long as the underlying
         types are the same.
    Go does not ahve type-hierarchy. so:
            type duration int64
            type myDuration duration
        myDuraiton is not type duration but type int64
    defined types and source types share the the same, base, underlying type.

Aliased Types -
    to alias type, we declare the type as we would a new type but instead a space after the name we place
        a assignment operator like so:
            type gram = uint8
            type rune = int32
    but do not use this without care.

Constants -
    constants belong to compile time. It is created at the compile time.
    Constants may or may not have a name and they are replaced at runtime by their value.
    Constant may or may not have a type but it will always have an initial value since it will not change.
    To declare a named constant use the syntax:
        const name int
            const ==> keyword to delcare a constant
            name  ==> constant name
            int   ==> constant type
    an unnamed constant is just a type literal.
    Since constants belong to compile time, variable runtime errors can sometimes be caught at compile time
        when using constants.

    Rules for using constants:
        constants are immutable
        can not initialize a constant with a runtime value
        can initialize using the len command on string literals

    you can initilaize a constant to a non-numeric type, nor do they need to be declared with a type
    just like declaring multiple variables you can declare multiple contants in the same manner.
    If a constnat's type and value are not declared, it will get the type and data from the 
        previous constant
    
Typeless Constants -
    when you declare a constant without a type. it becomes a untyped constant.
        this allows something like 3.14 * 2. If these were type this would not be allowed. 
    All basic literals are typeless.
    Typeless constants are like chameleon, they cha ge their type as needed.
    If the type is not specified, go implicitly converts the value to it's default type.
    Becasue of this we can mix some values together but not all. 

Iota - 
    Built in contant generator. This generator starts at 0(unless otherwise started) and increases
        by one at each line in a constant declaration. It will not reset until it hits another 
        constant declaration.

Common Naming Conventions in Go -
   Abbreviate. Use the first letter(s) of the word(s) to make them meaningful
        but more concise ie:
            s string
            i index
            val value
            fv flag value
            seen has seen?
            parsed parsing ok?
        things nedd to be more readable rather than verbose. This helps with maintainability.
        Smaller the scope, fewer the letters is a good rule of thumb
        camel case is ok, but don't start with a capital unless you want to export the object.
        Use all caps for common acronyms like API
        Do not stutter, or repeat words.
        Do not use underscores in names

Boolean Operators -
    Comparison Operators are used to compare two values. They return a bool value (true or false)
    The comparison operatros are:
        == ==> the equal operator. If oth valuse are the same than the expression returns true
        != ==> the not equal operator, the opposite of the equal op.
        <  ==> the less than operator, one value is less than the other.
        <= ==> less than equal to. If the value on the left is less than or equal to the one on the right.
        >  ==> greater than operator. Value on the left is greater than the one on the right.
        >= ==> same as the less than equal to, but checks if value on left is greater than or equal to the value on the right.

    If you can't assign the value, then you can't compare it.
        IE you can't compare a string to int since you can not assign a string to an int.
    
Logical Operator -
    Combines one or more boolean expressions and returns a boolean value.
    Can ONLY combine boolean value
    Logical operators:
        && (and)  both operands need to be true for the result to be true
        || (or)   at least one of the operands needs to be true.
        !  (not)  this takes the result of a boolean operaand and flips it to the opppsite
            IE if the result is true, then the not will return a false.

If Statement -
    is a control structure in go. It is a block of code that will only run if 
        a condition is met. The scope of the block is only for the if statement.
        It can access anythign outside its block but nothing con see what is 
        inside its block.
            if score > 3 {
                fmt.Println("good")
            }
        
            if                  ==> keyword to begin the if statement
            score > 3           ==> the condition that needs to be met. Score 
                                        must be greater than 3 to run the code 
                                        body
            {}                  ==> braces do denote the code block
            fmt.Println("good") ==> code body, this code is run if the condition
                                        on score is met
        if there is only once condition to be met, we do not need parentheses. 
            If there are multiple conditions like score > 3 and height < 5 then 
            we need prentheses like this (score > 3) && (height < 5)
        we can have multiple branches based on multiple conditions using the keywords
            else if. This branch will be checked only if the first if conditon is not met. 
            Just like the if statement though, the condiotn on the else if
            needs to be met in order for the body of code to run.
        if nothing is met we can have a body if code at the end after the keyword else, whos
            code block will only run if no conditions are met in any of the branches before it.
        As single if branch can only be used once, but we can have as many branches as needed.
            Same thing with the else branch. There can only be one else branch.

Error Handling -
    Why? Not everything goes as expected. Those issues must be addressed.
    error handling is crucial to write a successful program.
    
    nil is a predelcared identifier in go. It means that the value is not yet initialized yet.
    same as 
        Javascript ==> null
        python     ==> None
        java       ==> null
        ruby       ==> nil

    the zero value for a pointer based type is nil.
    Most error handling either returns nil or a value. If the value returned is nil, then everything
        in the program ran correctly. If a value is returned, then somehting went wrong and must be addressed.
        we can check for errors using an if statement to chek if the variable is nil or not.

    Go expects errors to be handled quickly and at the time that it can be encountered. This way 
        nothing truly unexpected happens. Rather than try and catch statements like other languages,
        go just expects the use of an if statement.

Short if Statement -
    we can put the short vairbale declaration and error check in a single line for an if statement
        if n, err := strconv.Atoi("42"); err == nil {}

        in this syntax combines the declaration and error checking in single moment. The only downside is 
            the variables are only created with in the scope of the if block of code.

Shadowing -
    this is a vairbale issue that occurs when a vairble is declared outside of an if statements and inside 
    the if condition. This is caused by the scope of the if block of code.

Switch Statement -
    Similar to an if statement but with a different syntax. 
    There are two switch statements one is a condition statement, one is a type statement
    Switch statements look for an equal value 
    Starts with the keyword switch. Each case clause insed the statement block begins with the keyword case.
        the case keyword is followed by a condiiton in the condition type of the switch statement.
            Syntax is as follows:
                city := "Paris"
                switch city {
                    case "Paris":
                        fmt.Println("France")
                }

            switch                   ==> keyword
            city                     ==> condition that will be used to search
            case                     ==> keyword to denote a possible operations
            "Paris"                  ==> the condtion that needs to be matched for the specific code
            : fmt.Println("France")  ==> body of code that runs should the condition be met.

    Rules for a switch statement:
        case values should be unique for each case
        types of the switch and case conditions need to be comparable
        the code inside the case blcok is exclusive to itself

    Switch statements have a default branch should it need a fallback. to make the default case we use
        the keyword default rather than case and it is immediately follwoed by a colon. The defualt clause
        can be anywhere inside the switch statement and there can only be one default clause per switch statement

    a case can have multiple conditions that call that case by using a comma separated list like this:
        case "Paris", "Lyon":
            fmt.Println("France")
    the print statement will be called whether Paris or Lyon is the value passed to the switch statement
    we can use a boolean value to start a switch statement. True will always run, false will not. 
        Although a switch statement is always true so specifing it is not necessary.
    a fallthrough executes the next clause's code without checking the condition. it uses the keyword fallthrough
        an example
            switch {
                case i > 0:
                    fmt.Print("big")
                    fallthrough
                case i > 0:
                    fmt.Print("positive")
                    fallthrough
                default:
                    fmt.Print("number")
            }
    There is such things as short switch, it is similar to the short if. 
        The declaration of the calling value is declared and assigned followed by a semicolon.
            switch im:= 10; true {} 

    If vs Switch -
        which do we use and when?
        a switch statement is used to make a long if statement more readable. 
            If an If statement becomes to unreadbale or large, try and convert it to a switch statement

